# 3. Join Implementation

Taking a look at our table joining journey.

| Join Journey Part | Start               | 	End             | 	Foreign Key      |
|-------------------|---------------------|---------------------|--------------------|
| Part 1            | ```rental```        | ```inventory```     | ```inventory_id``` |
| Part 2            | ```inventory```     | ```film```          | ```film_id```      |
| Part 3            | ```film```          | ```film_category``` | ```film_id```      |
| Part 4            | ```film_category``` | ```category```      | ```category_id```  |

## 3.1 Joins Part 1

After performing the analysis, its clear that we can chose either of the ```INNER JOIN``` OR ```LEFT JOIN``` as it won't make any difference for our example. We can check this ourself by running the following SQL code.

```sql
DROP TABLE IF EXISTS left_rental_join;
CREATE TEMP TABLE left_rental_join AS
SELECT
  rental.customer_id,
  rental.inventory_id,
  inventory.film_id
FROM dvd_rentals.rental
LEFT JOIN dvd_rentals.inventory
  ON rental.inventory_id = inventory.inventory_id;

DROP TABLE IF EXISTS inner_rental_join;
CREATE TEMP TABLE inner_rental_join AS
SELECT
  rental.customer_id,
  rental.inventory_id,
  inventory.film_id
FROM dvd_rentals.rental
INNER JOIN dvd_rentals.inventory
  ON rental.inventory_id = inventory.inventory_id;

SELECT
  'left join' AS join_type,
  COUNT(*) AS record_count,
  COUNT(DISTINCT inventory_id) AS unique_key_values
FROM left_rental_join
  
UNION

SELECT
  'inner join' AS join_type,
  COUNT(*) AS record_count,
  COUNT(DISTINCT inventory_id) AS unique_key_values
FROM inner_rental_join;
```

*Output:*

| join_type  | record_count | unique_key_values |
|------------|--------------|-------------------|
| inner join | 16044        | 4580              |
| left join  | 16044        | 4580              |

## 3.2 Join Part 2

### 3.2.1 What is the purpose?

Similar to part 1, now we need to work on joining the table ```inventory``` and ```film```. The purpose for this join can be defined as:
> We want to match the films on ```film_id``` so that we can get the film names.

### 3.2.2 Generating hypotheses from data

Some hypotheses that can be generated by looking at the data are as follows:
1. There be 1-to-many relationship for ```film_id``` and the rows of the ```dvd_rentals.inventory``` table as one specific film might have multiple copies to be purchased at the rental store.
2. There should be 1-to-1 relationship for ```film_id``` and the rows of the ```dvd_rentals.film``` table as it doesnâ€™t make sense for there to be duplicates in this ```dvd_rentals.film```.

And, we can now test our hypothesis using SQL.

### 3.2.3 Validating our hypotheses

For the first one,

```sql
WITH base_counts AS (
  SELECT 
    film_id,
    COUNT(*) AS record_count
  FROM dvd_rentals.inventory
  GROUP BY 1
)

SELECT 
  record_count,
  COUNT(DISTINCT film_id) AS unique_film_id_values
FROM base_counts
GROUP BY record_count
ORDER BY record_count;
```

*Output:*

| record_count | unique_film_id_values |
|--------------|-----------------------|
| 2            | 133                   |
| 3            | 131                   |
| 4            | 183                   |
| 5            | 136                   |
| 6            | 187                   |
| 7            | 116                   |
| 8            | 72                    |

So, our first hypotheses is valid as we can see there are multiple inventory records for a particular film as one film's copy can be available at multiple stores.

Moving on to check our second hypotheses, we can just do a group by on the ```film_id``` and sort it in descending order to check if there's just one row per unique ```film_id``` or not.

```sql
SELECT
  film_id,
  COUNT(*) AS film_count
FROM dvd_rentals.film
GROUP BY film_id
ORDER BY film_id DESC
LIMIT 5;
```

*Output:*

| film_id | film_count |
|---------|------------|
| 1000    | 1          |
| 999     | 1          |
| 998     | 1          |
| 997     | 1          |
| 996     | 1          |

Thus, we can confirm that there is one-to-one relationship for ```film_id``` in the ```film``` table.

