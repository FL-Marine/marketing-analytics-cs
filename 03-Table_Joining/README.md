# 3. Join Implementation

Taking a look at our table joining journey.

| Join Journey Part | Start               |  End                |  Foreign Key       |
|-------------------|---------------------|---------------------|--------------------|
| Part 1            | ```rental```        | ```inventory```     | ```inventory_id``` |
| Part 2            | ```inventory```     | ```film```          | ```film_id```      |
| Part 3            | ```film```          | ```film_category``` | ```film_id```      |
| Part 4            | ```film_category``` | ```category```      | ```category_id```  |

## 3.1 Joins Part 1

After performing the analysis, its clear that we can chose either of the ```INNER JOIN``` OR ```LEFT JOIN``` as it won't make any difference for our example. We can check this ourself by running the following SQL code.

```sql
DROP TABLE IF EXISTS left_rental_join;
CREATE TEMP TABLE left_rental_join AS
SELECT
  rental.customer_id,
  rental.inventory_id,
  inventory.film_id
FROM dvd_rentals.rental
LEFT JOIN dvd_rentals.inventory
  ON rental.inventory_id = inventory.inventory_id;

DROP TABLE IF EXISTS inner_rental_join;
CREATE TEMP TABLE inner_rental_join AS
SELECT
  rental.customer_id,
  rental.inventory_id,
  inventory.film_id
FROM dvd_rentals.rental
INNER JOIN dvd_rentals.inventory
  ON rental.inventory_id = inventory.inventory_id;

SELECT
  'left join' AS join_type,
  COUNT(*) AS record_count,
  COUNT(DISTINCT inventory_id) AS unique_key_values
FROM left_rental_join
  
UNION

SELECT
  'inner join' AS join_type,
  COUNT(*) AS record_count,
  COUNT(DISTINCT inventory_id) AS unique_key_values
FROM inner_rental_join;
```

*Output:*

| join_type  | record_count | unique_key_values |
|------------|--------------|-------------------|
| inner join | 16044        | 4580              |
| left join  | 16044        | 4580              |

## 3.2 Join Part 2

### 3.2.1 What is the purpose?

Similar to part 1, now we need to work on joining the table ```inventory``` and ```film```. The purpose for this join can be defined as:
> We want to match the films on ```film_id``` so that we can get the film names.

### 3.2.2 Generating hypotheses from data

Some hypotheses that can be generated by looking at the data are as follows:

1. There be 1-to-many relationship for ```film_id``` and the rows of the ```dvd_rentals.inventory``` table as one specific film might have multiple copies to be purchased at the rental store.
2. There should be 1-to-1 relationship for ```film_id``` and the rows of the ```dvd_rentals.film``` table as it doesnâ€™t make sense for there to be duplicates in this ```dvd_rentals.film```.

And, we can now test our hypothesis using SQL.

### 3.2.3 Validating our hypotheses

For the first one,

```sql
WITH base_counts AS (
  SELECT 
    film_id,
    COUNT(*) AS record_count
  FROM dvd_rentals.inventory
  GROUP BY 1
)

SELECT 
  record_count,
  COUNT(DISTINCT film_id) AS unique_film_id_values
FROM base_counts
GROUP BY record_count
ORDER BY record_count;
```

*Output:*

| record_count | unique_film_id_values |
|--------------|-----------------------|
| 2            | 133                   |
| 3            | 131                   |
| 4            | 183                   |
| 5            | 136                   |
| 6            | 187                   |
| 7            | 116                   |
| 8            | 72                    |

So, our first hypotheses is valid as we can see there are multiple inventory records for a particular film as one film's copy can be available at multiple stores.

Moving on to check our second hypotheses, we can just do a group by on the ```film_id``` and sort it in descending order to check if there's just one row per unique ```film_id``` or not.

```sql
SELECT
  film_id,
  COUNT(*) AS film_count
FROM dvd_rentals.film
GROUP BY film_id
ORDER BY film_id DESC
LIMIT 5;
```

*Output:*

| film_id | film_count |
|---------|------------|
| 1000    | 1          |
| 999     | 1          |
| 998     | 1          |
| 997     | 1          |
| 996     | 1          |

Thus, we can confirm that there is one-to-one relationship for ```film_id``` in the ```film``` table.

### 3.2.4 How many unique foreign key values exist in each table?

We can check this using the ANTI JOIN and see if there are any unique ```film_id``` foreign key which is not present in either left or right table.

**```inventory``` table foreign key analyisis for ```film_id```**

```sql
SELECT
  COUNT(DISTINCT film_id) AS total_count
FROM dvd_rentals.inventory
WHERE NOT EXISTS(
  SELECT film_id
  FROM dvd_rentals.film
  WHERE inventory.film_id = film.film_id
);
```

*Output:*

| total_count |
|-------------|
| 0           |

Here, we can see that all the ```film_id``` values in the inventory table are present in the ```film``` table.

Now, let's also try to implement the same for the right table ```film`` table.

```sql
SELECT
  COUNT(DISTINCT film_id) AS total_count
FROM dvd_rentals.film
WHERE NOT EXISTS(
  SELECT film_id
  FROM dvd_rentals.inventory
  WHERE inventory.film_id = film.film_id
);
```

*Output:*

| total_count |
|-------------|
| 42          |

Alright, so there is some discrepancy in the number of unique ```film_id``` values between the inventory & film table.

While, we are here, let's also check the total number of  foreign key distinct values that would be generated after we do the ```LEFT SEMI JOIN```.

```sql
SELECT
  COUNT(DISTINCT film_id) AS total_count
FROM dvd_rentals.inventory
WHERE EXISTS (
  SELECT film_id
  FROM dvd_rentals.film
  WHERE film.film_id = inventory.film_id
);
```

*Output:*

| total_count |
|-------------|
| 958         |

So, now that we know we have all our foreign key values in the ```inventory``` table, its time to decide our join and in this particular example as we have seen before it won't make a difference to chose either INNER or LEFT Join. We can test this by implementing both the joins and comparing the number of unique key values.

<details>
<summary>Click to view SQL code</summary>
<br>

```sql
DROP TABLE IF EXISTS left_join_part_2;
CREATE TEMP TABLE left_join_part_2 AS (
SELECT
  inventory.inventory_id,
  inventory.film_id,
  film.title
FROM dvd_rentals.inventory
LEFT JOIN dvd_rentals.film
  ON inventory.film_id = film.film_id
);

DROP TABLE IF EXISTS inner_join_part_2;
CREATE TEMP TABLE inner_join_part_2 AS (
SELECT 
  inventory.inventory_id,
  inventory.film_id,
  film.title
FROM dvd_rentals.inventory
LEFT JOIN dvd_rentals.film
  ON inventory.film_id = film.film_id
);

SELECT 
  'inner join' AS join_type,
  COUNT(*) AS row_counts,
  COUNT(DISTINCT film_id) AS unique_film_values
FROM inner_join_part_2

UNION

SELECT 
  'left join' AS join_type,
  COUNT(*) AS row_counts,
  COUNT(DISTINCT film_id) AS unique_film_values
FROM left_join_part_2;
```

</details>

*Output:*

| join_type  | row_counts | unique_film_values |
|------------|------------|--------------------|
| inner join | 4581       | 958                |
| left join  | 4581       | 958                |

### 3.2.5 Join implementation of part 1 & 2

Now, that we have decided on our type of join that we are going to be using, let's implement a three table ```INNER JOIN```.

```sql
DROP TABLE IF EXISTS join_part1_and_part2;
CREATE TEMP TABLE join_part1_and_part2 AS (
SELECT
  rental.customer_id,
  inventory.film_id,
  film.title
FROM dvd_rentals.rental
INNER JOIN dvd_rentals.inventory
  ON rental.inventory_id = inventory.inventory_id
INNER JOIN dvd_rentals.film
  ON inventory.film_id = film.film_id
);

SELECT * 
FROM join_part1_and_part2
ORDER BY customer_id
LIMIT 5;
```

*Output:*

| customer_id | film_id | title                |
|-------------|---------|----------------------|
| 1           | 308     | FERRIS MOTHER        |
| 1           | 243     | DOORS PRESIDENT      |
| 1           | 924     | UNFORGIVEN ZOOLANDER |
| 1           | 480     | JEEPERS WEDDING      |
| 1           | 611     | MUSKETEERS WAIT      |

### 3.2.6 Join implementation of part 3 & 4

We can follow all the above steps and come up with a purpose, hypotheses validate it for the join part 3 & part 4. But, if we go through all of it we'll find that there is one-to-one relationship for ```film_id``` in both the film & film_category table for the part 3. 

Also, for the part 4, there is one-to-many relationship between ```category_id``` in the left table i.e. film_category table and a one-to-one relationship for the category table.

Hence, we will just go ahead with our ```INNER JOIN``` implementation for part 3 and part 4 tables as before.

```sql
DROP TABLE IF EXISTS join_part3_and_part4;
CREATE TEMP TABLE join_part3_and_part4 AS (
SELECT 
  film.film_id,
  film_category.category_id,
  category.name AS category_name
FROM dvd_rentals.film
INNER JOIN dvd_rentals.film_category
  ON film.film_id = film_category.film_id
INNER JOIN dvd_rentals.category
  ON film_category.category_id = category.category_id
);

SELECT *
FROM join_part3_and_part4
ORDER BY film_id
LIMIT 5;
```

*Output:*

| film_id | category_id | category_name |
|---------|-------------|---------------|
| 1       | 6           | Documentary   |
| 2       | 11          | Horror        |
| 3       | 6           | Documentary   |
| 4       | 11          | Horror        |
| 5       | 8           | Family        |

## 3.3 Final Join implementation

Now, lets create our full final dataset for part 1 upto part 4 using ```INNER JOIN``` using the same implementation as above.

```sql
DROP TABLE IF EXISTS final_table_join_data;
CREATE TEMP TABLE final_table_join_data AS (
SELECT 
  rental.customer_id,
  film.film_id,
  film.title,
  film_category.category_id,
  category.name AS category_name
FROM dvd_rentals.rental
INNER JOIN dvd_rentals.inventory
  ON rental.inventory_id = inventory.inventory_id
INNER JOIN dvd_rentals.film
  ON inventory.film_id = film.film_id
INNER JOIN dvd_rentals.film_category
  ON film.film_id = film_category.film_id
INNER JOIN dvd_rentals.category
  ON film_category.category_id = category.category_id
);

SELECT *
FROM final_table_join_data
LIMIT 10;
```

*Output:*

| customer_id | film_id | title           | category_id | category_name |
|-------------|---------|-----------------|-------------|---------------|
| 130         | 80      | BLANKET BEVERLY | 8           | Family        |
| 459         | 333     | FREAKY POCUS    | 12          | Music         |
| 408         | 373     | GRADUATE LORD   | 3           | Children      |
| 333         | 535     | LOVE SUICIDES   | 11          | Horror        |
| 222         | 450     | IDOLS SNATCHERS | 3           | Children      |
| 549         | 613     | MYSTIC TRUMAN   | 5           | Comedy        |
| 269         | 870     | SWARM GOLD      | 11          | Horror        |
| 239         | 510     | LAWLESS VISION  | 2           | Animation     |
| 126         | 565     | MATRIX SNOWMAN  | 9           | Foreign       |
| 399         | 396     | HANGING DEEP    | 7           | Drama         |

This is now our final table output such that we can run our aggregations and solve the business problems.

